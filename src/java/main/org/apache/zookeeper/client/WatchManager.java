package org.apache.zookeeper.client;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.log4j.Logger;
import org.apache.zookeeper.ClientCnxn;
import org.apache.zookeeper.Watcher;

/**
 * Manage watchers & handle events generated by the ClientCnxn object.
 *
 * This class does not belong to the public ZooKeeper API!
 */
public class WatchManager {
    private static final Logger LOG = Logger.getLogger(WatchManager.class);
    
    final Map<String, Set<Watcher>> dataWatches =
        new HashMap<String, Set<Watcher>>();
    final Map<String, Set<Watcher>> existWatches =
        new HashMap<String, Set<Watcher>>();
    final Map<String, Set<Watcher>> childWatches =
        new HashMap<String, Set<Watcher>>();

    volatile Watcher defaultWatcher;

    final private void addTo(Set<Watcher> from, Set<Watcher> to) {
        if (from != null) {
            to.addAll(from);
        }
    }

    /**
     * Return a set of watchers that should be notified of the event. The 
     * manager must not notify the watcher(s), however it will update it's 
     * internal structure as if the watches had triggered. The intent being 
     * that the callee is now responsible for notifying the watchers of the 
     * event, possibly at some later time.
     */    
    public Set<Watcher> materialize(Watcher.Event.KeeperState state,
                                    Watcher.Event.EventType type,
                                    String clientPath)
    {
        Set<Watcher> result = new HashSet<Watcher>();

        switch (type) {
        case None:
            result.add(defaultWatcher);
            for(Set<Watcher> ws: dataWatches.values()) {
                result.addAll(ws);
            }
            for(Set<Watcher> ws: existWatches.values()) {
                result.addAll(ws);
            }
            for(Set<Watcher> ws: childWatches.values()) {
                result.addAll(ws);
            }

            // clear the watches if auto watch reset is not enabled
            if (ClientCnxn.getDisableAutoResetWatch() &&
                    state != Watcher.Event.KeeperState.SyncConnected)
            {
                synchronized(dataWatches) {
                    dataWatches.clear();
                }
                synchronized(existWatches) {
                    existWatches.clear();
                }
                synchronized(childWatches) {
                    childWatches.clear();
                }
            }

            return result;
        case NodeDataChanged:
        case NodeCreated:
            synchronized (dataWatches) {
                addTo(dataWatches.remove(clientPath), result);
            }
            synchronized (existWatches) {
                addTo(existWatches.remove(clientPath), result);
            }
            break;
        case NodeChildrenChanged:
            synchronized (childWatches) {
                addTo(childWatches.remove(clientPath), result);
            }
            break;
        case NodeDeleted:
            synchronized (dataWatches) {
                addTo(dataWatches.remove(clientPath), result);
            }
            // XXX This shouldn't be needed, but just in case
            synchronized (existWatches) {
                Set<Watcher> list = existWatches.remove(clientPath);
                if (list != null) {
                    addTo(existWatches.remove(clientPath), result);
                    LOG.warn("We are triggering an exists watch for delete! Shouldn't happen!");
                }
            }
            synchronized (childWatches) {
                addTo(childWatches.remove(clientPath), result);
            }
            break;
        default:
            String msg = "Unhandled watch event type " + type
                + " with state " + state + " on path " + clientPath;
            LOG.error(msg);
            throw new RuntimeException(msg);
        }

        return result;
    }
    
    public List<String> getDataWatches() {
        List<String> rc = new ArrayList<String>(dataWatches.keySet());
        return rc;
    }
    public List<String> getExistWatches() {
        List<String> rc =  new ArrayList<String>(existWatches.keySet());
        return rc;
    }
    public List<String> getChildWatches() {
        List<String> rc = new ArrayList<String>(childWatches.keySet());
        return rc;
    }
    
    public Watcher getDefaultWatcher() {
        return defaultWatcher;
    }
    
    public void setDefaultWatcher(Watcher defaultWatcher) {
        this.defaultWatcher = defaultWatcher;
    }
    
    public boolean hasWatches() {
        return !dataWatches.isEmpty() && !existWatches.isEmpty()
                && !childWatches.isEmpty();        
    }
}